// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlcgen

import (
	"context"
	"database/sql"
)

const deleteAllCards = `-- name: DeleteAllCards :exec
DELETE FROM cards
`

func (q *Queries) DeleteAllCards(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllCards)
	return err
}

const deleteAllProjects = `-- name: DeleteAllProjects :exec
DELETE FROM projects
`

func (q *Queries) DeleteAllProjects(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllProjects)
	return err
}

const deleteCardsByProject = `-- name: DeleteCardsByProject :exec
DELETE FROM cards WHERE project_slug = ?
`

func (q *Queries) DeleteCardsByProject(ctx context.Context, projectSlug string) error {
	_, err := q.db.ExecContext(ctx, deleteCardsByProject, projectSlug)
	return err
}

const deleteProjectBySlug = `-- name: DeleteProjectBySlug :exec
DELETE FROM projects WHERE slug = ?
`

func (q *Queries) DeleteProjectBySlug(ctx context.Context, slug string) error {
	_, err := q.db.ExecContext(ctx, deleteProjectBySlug, slug)
	return err
}

const hardDeleteCard = `-- name: HardDeleteCard :exec
DELETE FROM cards WHERE project_slug = ? AND number = ?
`

type HardDeleteCardParams struct {
	ProjectSlug string
	Number      int64
}

func (q *Queries) HardDeleteCard(ctx context.Context, arg HardDeleteCardParams) error {
	_, err := q.db.ExecContext(ctx, hardDeleteCard, arg.ProjectSlug, arg.Number)
	return err
}

const initCardsTable = `-- name: InitCardsTable :exec
CREATE TABLE IF NOT EXISTS cards (
  id TEXT PRIMARY KEY,
  project_slug TEXT NOT NULL,
  number INTEGER NOT NULL,
  title TEXT NOT NULL,
  branch TEXT,
  status TEXT NOT NULL,
  deleted INTEGER NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  comments_count INTEGER NOT NULL,
  history_count INTEGER NOT NULL,
  todos_count INTEGER NOT NULL,
  todos_completed_count INTEGER NOT NULL,
  acceptance_criteria_count INTEGER NOT NULL,
  acceptance_criteria_completed_count INTEGER NOT NULL,
  UNIQUE(project_slug, number)
)
`

func (q *Queries) InitCardsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, initCardsTable)
	return err
}

const initProjectsTable = `-- name: InitProjectsTable :exec
CREATE TABLE IF NOT EXISTS projects (
  slug TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  local_path TEXT,
  remote_url TEXT,
  next_card_seq INTEGER NOT NULL,
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL
)
`

func (q *Queries) InitProjectsTable(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, initProjectsTable)
	return err
}

const insertCard = `-- name: InsertCard :exec
INSERT INTO cards (
  id, project_slug, number, title, branch, status, deleted, created_at, updated_at, comments_count, history_count, todos_count, todos_completed_count, acceptance_criteria_count, acceptance_criteria_completed_count
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertCardParams struct {
	ID                               string
	ProjectSlug                      string
	Number                           int64
	Title                            string
	Branch                           sql.NullString
	Status                           string
	Deleted                          int64
	CreatedAt                        string
	UpdatedAt                        string
	CommentsCount                    int64
	HistoryCount                     int64
	TodosCount                       int64
	TodosCompletedCount              int64
	AcceptanceCriteriaCount          int64
	AcceptanceCriteriaCompletedCount int64
}

func (q *Queries) InsertCard(ctx context.Context, arg InsertCardParams) error {
	_, err := q.db.ExecContext(ctx, insertCard,
		arg.ID,
		arg.ProjectSlug,
		arg.Number,
		arg.Title,
		arg.Branch,
		arg.Status,
		arg.Deleted,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CommentsCount,
		arg.HistoryCount,
		arg.TodosCount,
		arg.TodosCompletedCount,
		arg.AcceptanceCriteriaCount,
		arg.AcceptanceCriteriaCompletedCount,
	)
	return err
}

const insertProject = `-- name: InsertProject :exec
INSERT INTO projects (slug, name, local_path, remote_url, next_card_seq, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type InsertProjectParams struct {
	Slug        string
	Name        string
	LocalPath   sql.NullString
	RemoteUrl   sql.NullString
	NextCardSeq int64
	CreatedAt   string
	UpdatedAt   string
}

func (q *Queries) InsertProject(ctx context.Context, arg InsertProjectParams) error {
	_, err := q.db.ExecContext(ctx, insertProject,
		arg.Slug,
		arg.Name,
		arg.LocalPath,
		arg.RemoteUrl,
		arg.NextCardSeq,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const listCardsActive = `-- name: ListCardsActive :many
SELECT id, project_slug, number, title, branch, status, deleted, created_at, updated_at, comments_count, history_count, todos_count, todos_completed_count, acceptance_criteria_count, acceptance_criteria_completed_count
FROM cards
WHERE project_slug = ? AND deleted = 0
ORDER BY number ASC
`

func (q *Queries) ListCardsActive(ctx context.Context, projectSlug string) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCardsActive, projectSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Card{}
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.ProjectSlug,
			&i.Number,
			&i.Title,
			&i.Branch,
			&i.Status,
			&i.Deleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CommentsCount,
			&i.HistoryCount,
			&i.TodosCount,
			&i.TodosCompletedCount,
			&i.AcceptanceCriteriaCount,
			&i.AcceptanceCriteriaCompletedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCardsWithDeleted = `-- name: ListCardsWithDeleted :many
SELECT id, project_slug, number, title, branch, status, deleted, created_at, updated_at, comments_count, history_count, todos_count, todos_completed_count, acceptance_criteria_count, acceptance_criteria_completed_count
FROM cards
WHERE project_slug = ?
ORDER BY number ASC
`

func (q *Queries) ListCardsWithDeleted(ctx context.Context, projectSlug string) ([]Card, error) {
	rows, err := q.db.QueryContext(ctx, listCardsWithDeleted, projectSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Card{}
	for rows.Next() {
		var i Card
		if err := rows.Scan(
			&i.ID,
			&i.ProjectSlug,
			&i.Number,
			&i.Title,
			&i.Branch,
			&i.Status,
			&i.Deleted,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CommentsCount,
			&i.HistoryCount,
			&i.TodosCount,
			&i.TodosCompletedCount,
			&i.AcceptanceCriteriaCount,
			&i.AcceptanceCriteriaCompletedCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCard = `-- name: UpsertCard :exec
INSERT INTO cards (
  id, project_slug, number, title, branch, status, deleted, created_at, updated_at, comments_count, history_count, todos_count, todos_completed_count, acceptance_criteria_count, acceptance_criteria_completed_count
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
  project_slug = excluded.project_slug,
  number = excluded.number,
  title = excluded.title,
  branch = excluded.branch,
  status = excluded.status,
  deleted = excluded.deleted,
  created_at = excluded.created_at,
  updated_at = excluded.updated_at,
  comments_count = excluded.comments_count,
  history_count = excluded.history_count,
  todos_count = excluded.todos_count,
  todos_completed_count = excluded.todos_completed_count,
  acceptance_criteria_count = excluded.acceptance_criteria_count,
  acceptance_criteria_completed_count = excluded.acceptance_criteria_completed_count
`

type UpsertCardParams struct {
	ID                               string
	ProjectSlug                      string
	Number                           int64
	Title                            string
	Branch                           sql.NullString
	Status                           string
	Deleted                          int64
	CreatedAt                        string
	UpdatedAt                        string
	CommentsCount                    int64
	HistoryCount                     int64
	TodosCount                       int64
	TodosCompletedCount              int64
	AcceptanceCriteriaCount          int64
	AcceptanceCriteriaCompletedCount int64
}

func (q *Queries) UpsertCard(ctx context.Context, arg UpsertCardParams) error {
	_, err := q.db.ExecContext(ctx, upsertCard,
		arg.ID,
		arg.ProjectSlug,
		arg.Number,
		arg.Title,
		arg.Branch,
		arg.Status,
		arg.Deleted,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CommentsCount,
		arg.HistoryCount,
		arg.TodosCount,
		arg.TodosCompletedCount,
		arg.AcceptanceCriteriaCount,
		arg.AcceptanceCriteriaCompletedCount,
	)
	return err
}

const upsertProject = `-- name: UpsertProject :exec
INSERT INTO projects (slug, name, local_path, remote_url, next_card_seq, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(slug) DO UPDATE SET
  name = excluded.name,
  local_path = excluded.local_path,
  remote_url = excluded.remote_url,
  next_card_seq = excluded.next_card_seq,
  created_at = excluded.created_at,
  updated_at = excluded.updated_at
`

type UpsertProjectParams struct {
	Slug        string
	Name        string
	LocalPath   sql.NullString
	RemoteUrl   sql.NullString
	NextCardSeq int64
	CreatedAt   string
	UpdatedAt   string
}

func (q *Queries) UpsertProject(ctx context.Context, arg UpsertProjectParams) error {
	_, err := q.db.ExecContext(ctx, upsertProject,
		arg.Slug,
		arg.Name,
		arg.LocalPath,
		arg.RemoteUrl,
		arg.NextCardSeq,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
